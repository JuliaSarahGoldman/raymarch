#version 410 // -*- c++ -*-
#include <g3dmath.glsl>
#include <Texture/Texture.glsl>
      
#define subtractSurface(h, i, j, X, m) max(-h(i, X, m), h(j, X, m))
#define test(f, s, X, m) smin(f(s, X, m), 100, .5)
#define repeat(h, period, s, X, m) h(s, mod(X, period), m)

      

// Input arguments from the C++ program
uniform mat4x3         cameraToWorldMatrix;

uniform TextureCube    environmentMap;

uniform float          tanHalfFieldOfViewY;
uniform float          projectionMatrix22, projectionMatrix23;

// Output to the App::m_framebuffer
out Color3 pixelColor;

struct Material{
    Color3 lambertian;
    Color3 glossy;
    float sigma;
};

struct Surfel{
    Material material;
    Point3 position;
    Vector3 normal;
};

struct ISphere{
    Point3 center;
    float radius;
    Material material;
};

struct IBox{
    Point3 center;
    float radius;
    Material material;
};

struct ITorus{
    Point3 center;
    float minorRadius;
    float majorRadius;
    Material material;
};

struct ICylinder{
    Point3 center;
    float radius;
    float halfHeight;
    Material material;
};

const ISphere sphere1 = ISphere(Point3(0,1,0), 1.0, Material(Color3(.85,.02,.25), Color3(.3,.3,.3), 30));
const IBox box2 = IBox(Point3(0,1.5,.0), .5, Material(Color3(.7,0,.9), Color3(0,0,0), 0));
//const ISphere sphere2 = ISphere(Point3(-1.3,2,2), .5, Material(Color3(0,0,0), Color3(0,.5,.8), 2));
const ISphere sphere2 = ISphere(Point3(-1.3,2,2), .5, Material(Color3(.9,.5,0), Color3(0,0,0), 0));
const ISphere sphere3 = ISphere(Point3(-1.3,2,2.4), .5, Material(Color3(.9,.5,0), Color3(0,0,0), 0));
const ITorus torus = ITorus(Point3(-2, 3, -2), 1.0, .5, Material(Color3(0,.7,1), Color3(0,0,0), 0));
const ITorus torus2 = ITorus(Point3(-1.7, 3, -2), 1.0, .5, Material(Color3(0,.7,1), Color3(0,0,0), 0));
const ICylinder cylinder = ICylinder(Point3(2, 1.5, 2), .5, 1.0, Material(Color3(0,.7,1), Color3(0,1,0), 10));
const ICylinder cylinder2 = ICylinder(Point3(2, 1.8, 2), .45, 1.3, Material(Color3(0,.7,1), Color3(0,1,0), 10));
const ISphere testSphere = ISphere(Point3(.5,.5,0.0), 0.5, Material(Color3(.85,.02,.25), Color3(0,0,0), 0));


float smin(float a, float b, float blendRadius) {
    float c = saturate(0.5 + (b - a) * (0.5 / blendRadius));
    return lerp(b, a, c) - blendRadius * c * (1.0 - c);
}



float sceneDistance(const ICylinder cylinder, Point3 X, inout Material material){
    material =cylinder.material;
    Vector2 d = abs(Vector2(length(X.xz - cylinder.center.xz), X.y - cylinder.center.y)) - Vector2(cylinder.radius, cylinder.halfHeight);
    return min(maxComponent(d), 0) + length(max(d, Vector2(0, 0)));
}
      

float sceneDistance(const ITorus torus, Point3 X, inout Material material) {
    material = torus.material;
    return length(vec2(length(X.xz - torus.center.xz) - torus.minorRadius, X.y - torus.center.y)) - torus.majorRadius;
}
      
float sceneDistance(const ISphere sphere, Point3 X, inout Material material){
    material = sphere.material;
    return length(X - sphere.center) - sphere.radius;
}

float sceneDistance(const IBox box, Point3 X, inout Material material){
    material = box.material;
    Vector3 d = abs(X - box.center) - box.radius;
    return min(maxComponent(d), 0) + length(max(d, Vector3(0, 0, 0)));
}

//Fix/replace Currently uses second material
float sceneDistance(const ISphere sphere, const IBox box, Point3 X, inout Material material) {
    return max(-sceneDistance(box, X, material), 
                         sceneDistance(sphere, X, material));
}

float sceneDistance(Point3 X, inout Material material) {
    //const Point3  C = Point3(0,0,0);
    //const float   r = 1.0;
   /* ISphere sphere1 = ISphere(Point3(0,0,0), 1.0, Material(Color3(1,0,1)));
    IBox box2 = IBox(Point3(1.3,.5,.5), .5, Material(Color3(.3,0,1)));
    ITorus torus = ITorus(Point3(-2, 2, -2), 1.0, .5, Material(Color3(0,.7,1)));*/

    // Replace this with a union of the objects in the scene.  You
    // don't necessarily need an explicit list of separate surfaces in
    // the way that the analytic tracer does.
    //
    // Think about how to change the API so that the closest surface
    // in a union sets the material. For that, some For intersection,
    // blending, and subtraction, whichever surface dominates the
    // distance computation should set the material.

    return sceneDistance(testSphere, X, material);

    Material tmp1, tmp2, tmp3, tmp4, tmp5;
    float t1,t2, t3, t4, t5;
    t2 = inf;
    //t1 = sceneDistance(sphere1, box2, X, tmp1);
    t1 = subtractSurface(sceneDistance, box2, sphere1, X, tmp1);
    t2 = sceneDistance(sphere3, X, tmp5);
    //t3 = sceneDistance(torus, X, tmp3);
    t3 = subtractSurface(sceneDistance, torus2, torus, X, tmp3);
    t4 = subtractSurface(sceneDistance, cylinder2, cylinder, X, tmp4);// sceneDistance(cylinder, X, tmp4);
    t5 = sceneDistance(sphere2, X, tmp5);
    if (t1 < t3 && t1 < min(t2, t5) && t1 < t4){
        material = tmp1;
        //float color = mod(X.x*X.y*X.z,.1);
        /*float sum = mod(X.x + X.y + X.z, 2);
        if (sum > 1){
            sum = 1;
        }
        else{
            sum = 0;
        }*/

        /*float sum = 1;
        float width = .2;
        float x = mod(X.x, 2*width);
        float y = mod(X.y, 2*width);
        float z = mod(X.z, 2*width);
        if ((x < width && y < width) || (x > width && y > width)){
            sum = 0;
        }
        material.lambertian = Color3(sum);
        */
        material.lambertian = normalize((mod(X, .1)));
        return t1;
    }
    else if(t3 < t1 && t3 < min(t2,t5) && t3 < t4){
        material = tmp3;
        material.lambertian *= normalize(mod(X, .5));
        return t3;
    }
    else if(t4 < t1 && t4 < min(t2,t5) && t4 < t3){
        material = tmp4;
        material.lambertian = Color3(.9, 0, .3);
        float width = .05;
        float x = mod(X.x, 2*width);
        float y = mod(X.y, 2*width);
        float z = mod(X.z, 2*width);
        if ((y < width)){// && y < width) || (x > width && y > width)){
            material.lambertian = Color3(.9, 1, 1);
        }
        return t4;
    }
    else{
        material = tmp5;
        material.lambertian *= normalize(mod(X, 1));
        return smin(t2, t5, .05);
    }

    //return length(X - C) - r;

    //return sceneDistance(sphere1, X, material);
}

float sceneDistance(Point3 X){
    Material ignore;
    return sceneDistance(X, ignore);
}


bool traceRayAnalytic(Point3 P, Vector3 w, inout Surfel surfel, in out float maxDistance) {
    float t = -P.y/w.y;
    if ((t < maxDistance) && (sign(w.y*P.y) < 0.0)){
//    if (t > 0.0){
//    if (t < maxDistance && t > 0.0){
       surfel.material.lambertian = Color3(1,1,1);
       surfel.normal = Vector3(0,1,0);
       surfel.position = P + w*t;
       maxDistance = t;
       return true;
    }
    else{
        return false;
    }
}

bool traceRayMarch(Point3 P, Vector3 w, inout Surfel surfel, inout float maxDistance){
    //const float maxDistance   = 1e10;
    const int   maxIterations = 100;
    const float closeEnough   = 1e-2;
    float t = 0;
    Material material;
    for (int i = 0; ((i < maxIterations) && (t < maxDistance)); ++i) {
        float dt = sceneDistance(P + w * t, material);
        t += dt;
        if (dt < closeEnough) {
            maxDistance = t;
            surfel.position = P + w*t;
            float eps = 1e-4;
            Point3 Q = P + w*(t-eps);
            surfel.normal = normalize(Vector3(sceneDistance(Q+Vector3(eps, 0, 0)), sceneDistance(Q+Vector3(0, eps, 0)), sceneDistance(Q+Vector3(0, 0, eps)))-sceneDistance(Q, surfel.material));//Vector3(0,1,0);
            //surfel.material = material;
            return true;
        }
    }
    return false;
//    return sampleTexture(environmentMap, w).rgb;
}

bool traceRay(Point3 P, Vector3 w, inout Surfel surfel, inout float maxDistance){
    bool hit = traceRayAnalytic(P, w, surfel, maxDistance);
    hit = traceRayMarch(P, w, surfel, maxDistance) || hit;
    return hit;
}


void main() {

    // Generate an eye ray in camera space, and then transform to world space

    // Primary ray origin    
    Point3 P  = cameraToWorldMatrix[3];

    // Primary ray direction
    Vector3 w = Matrix3(cameraToWorldMatrix) * 
        normalize(Vector3((gl_FragCoord.xy - g3d_FragCoordExtent / 2.0) * Vector2(1, -1),
                          g3d_FragCoordExtent.y / ( -2.0 * tanHalfFieldOfViewY)));

    float maxDist = inf;       

    //////////////////////////////////////

    //pixelColor = (w + 1)/2;

    // Render the scene here

    //Code for checkerboard
    /*
    float width = 16;
    float x = mod(gl_FragCoord.x, 2*width);
    float y = mod(gl_FragCoord.y, 2*width);
    if ((x < width && y < width) || (x > width && y > width)){
        pixelColor = Color3(0, 0, 0);
    } else{
        pixelColor = Color3(1,1,1);
    }*/
   
    Surfel surfel;
    if (traceRay(P, w, surfel, maxDist)){
       
       // pixelColor = surfel.material.lambertian;
        Vector3 wi = normalize(Vector3(1,1,1));
        Vector3 n = surfel.normal;
        Radiance3 biradiance = Radiance3(2.8, 2.3,1);
        Radiance3 ambientRadiance = Radiance3(.5, .3, .3)*surfel.material.lambertian;
        Surfel ignore;
        float shadowDist = inf;
        bool shadow = traceRay(surfel.position + n*.1, wi, ignore, shadowDist);
        Vector3 wo = -w;
        Vector3 wh = normalize(wi+wo);
        Color3 f = (surfel.material.lambertian/pi)+ (pow(max(dot(n,wh),0), max(surfel.material.sigma,1))*(surfel.material.sigma+8)*surfel.material.glossy)/(8*pi);
        pixelColor = f*biradiance*max(0,dot(n, wi))*float(!shadow)+ambientRadiance;

        //pixelColor = P;
        //pixelColor = (n+1)/2;
    } else{
        pixelColor = sampleTexture(environmentMap, w).rgb;
    }

    //////////////////////////////////////
     
    // Camera space z value
    float csZ = maxDist / w.z;
    
    // Pack into standard OpenGL depth buffer format to make the result compatible
    // with rasterization and post-processing.
    gl_FragDepth = (maxDist == inf) ? 1.0 : ((projectionMatrix22 * csZ + projectionMatrix23) / -csZ);
}
