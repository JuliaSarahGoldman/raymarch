#version 410 // -*- c++ -*-
#include <g3dmath.glsl>
#include <Texture/Texture.glsl>
      
//#define subtractSurface(h, i, j, X, m) max(-h(i, X, m), h(j, X, m))
      

// Input arguments from the C++ program
uniform mat4x3         cameraToWorldMatrix;

uniform TextureCube    environmentMap;

uniform float          tanHalfFieldOfViewY;
uniform float          projectionMatrix22, projectionMatrix23;

// Output to the App::m_framebuffer
out Color3 pixelColor;

struct Material{
    Color3 lambertian;
    Color3 glossy;
    float sigma;
};

struct Surfel{
    Material material;
    Point3 position;
    Vector3 normal;
};

struct ISphere{
    Point3 center;
    float radius;
    Material material;
};

struct IBox{
    Point3 center;
    float radius;
    Material material;
};

struct ITorus{
    Point3 center;
    float minorRadius;
    float majorRadius;
    Material material;
};

struct ICylinder{
    Point3 center;
    float radius;
    float halfHeight;
    Material material;
};

const ISphere sphere1 = ISphere(Point3(0,1,0), 1.0, Material(Color3(.85,.02,.25), Color3(.3,.3,.3), 30));
const IBox box2 = IBox(Point3(0,1.5,.0), .5, Material(Color3(.7,0,.9), Color3(0,0,0), 0));
const ISphere sphere2 = ISphere(Point3(-1.3,2,2), .5, Material(Color3(0,0,0), Color3(0,.5,.8), 2));
const ITorus torus = ITorus(Point3(-2, 3, -2), 1.0, .5, Material(Color3(0,.7,1), Color3(0,0,0), 0));
const ICylinder cylinder = ICylinder(Point3(2, 1.5, 2), .5, 1.0, Material(Color3(0,.7,1), Color3(0,1,0), 10));







float sceneDistance(const ICylinder cylinder, Point3 X, inout Material material){
    material =cylinder.material;
    Vector2 d = abs(Vector2(length(X.xz - cylinder.center.xz), X.y - cylinder.center.y)) - Vector2(cylinder.radius, cylinder.halfHeight);
    return min(maxComponent(d), 0) + length(max(d, Vector2(0, 0)));
}
      

float sceneDistance(const ITorus torus, Point3 X, inout Material material) {
    material = torus.material;
    return length(vec2(length(X.xz - torus.center.xz) - torus.minorRadius, X.y - torus.center.y)) - torus.majorRadius;
}
      
float sceneDistance(const ISphere sphere, Point3 X, inout Material material){
    material = sphere.material;
    return length(X - sphere.center) - sphere.radius;
}

float sceneDistance(const IBox box, Point3 X, inout Material material){
    material = box.material;
    Vector3 d = abs(X - box.center) - box.radius;
    return min(maxComponent(d), 0) + length(max(d, Vector3(0, 0, 0)));
}

//Fix/replace Currently uses second material
float sceneDistance(const ISphere sphere, const IBox box, Point3 X, inout Material material) {
    return max(-sceneDistance(box, X, material), 
                         sceneDistance(sphere, X, material));
}

float sceneDistance(Point3 X, inout Material material) {
    //const Point3  C = Point3(0,0,0);
    //const float   r = 1.0;
   /* ISphere sphere1 = ISphere(Point3(0,0,0), 1.0, Material(Color3(1,0,1)));
    IBox box2 = IBox(Point3(1.3,.5,.5), .5, Material(Color3(.3,0,1)));
    ITorus torus = ITorus(Point3(-2, 2, -2), 1.0, .5, Material(Color3(0,.7,1)));*/

    // Replace this with a union of the objects in the scene.  You
    // don't necessarily need an explicit list of separate surfaces in
    // the way that the analytic tracer does.
    //
    // Think about how to change the API so that the closest surface
    // in a union sets the material. For that, some For intersection,
    // blending, and subtraction, whichever surface dominates the
    // distance computation should set the material.
    Material tmp1, tmp2, tmp3, tmp5;
    float t1,t2, t3, t4, t5;
    t2 = inf;
    t1 = sceneDistance(sphere1, box2, X, tmp1);
    //t2 = subtractSurface(sceneDistance, box2, sphere1, X, tmp1);
    //t2 = sceneDistance(box2, X, tmp2);
    t3 = sceneDistance(torus, X, tmp3);
    t4 = sceneDistance(cylinder, X, tmp3);
    t5 = sceneDistance(sphere2, X, tmp5);
    if (t1 < t2 && t1 < min(t3, t4) && t1 < t5){
        material = tmp1;
        return t1;
    }
    else if(t2 < t1 && t2 < min(t3,t4) && t2 < t5){
        material = tmp2;
        return t2;
    }
    else if(t5 < t1 && t5 < min(t3,t4) && t5 < t2){
        material = tmp5;
        return t5;
    }
    else{
        material = tmp3;
        return min(t3, t4);
    }

    //return length(X - C) - r;

    //return sceneDistance(sphere1, X, material);
}

float sceneDistance(Point3 X){
    Material ignore;
    return sceneDistance(X, ignore);
}


bool traceRayAnalytic(Point3 P, Vector3 w, inout Surfel surfel, in out float maxDistance) {
    float t = -P.y/w.y;
    if ((t < maxDistance) && (sign(w.y*P.y) < 0.0)){
//    if (t > 0.0){
//    if (t < maxDistance && t > 0.0){
       surfel.material.lambertian = Color3(1,1,1);
       surfel.normal = Vector3(0,1,0);
       surfel.position = P + w*t;
       maxDistance = t;
       return true;
    }
    else{
        return false;
    }
}

bool traceRayMarch(Point3 P, Vector3 w, inout Surfel surfel, inout float maxDistance){
    //const float maxDistance   = 1e10;
    const int   maxIterations = 100;
    const float closeEnough   = 1e-2;
    float t = 0;
    Material material;
    for (int i = 0; ((i < maxIterations) && (t < maxDistance)); ++i) {
        float dt = sceneDistance(P + w * t, material);
        t += dt;
        if (dt < closeEnough) {
            maxDistance = t;
            surfel.position = P + w*t;
            float eps = 1e-4;
            Point3 Q = P + w*(t-eps);
            surfel.normal = normalize(Vector3(sceneDistance(Q+Vector3(eps, 0, 0)), sceneDistance(Q+Vector3(0, eps, 0)), sceneDistance(Q+Vector3(0, 0, eps)))-sceneDistance(Q, surfel.material));//Vector3(0,1,0);
            //surfel.material = material;
            return true;
        }
    }
    return false;
//    return sampleTexture(environmentMap, w).rgb;
}

bool traceRay(Point3 P, Vector3 w, inout Surfel surfel, inout float maxDistance){
    bool hit = traceRayAnalytic(P, w, surfel, maxDistance);
    hit = traceRayMarch(P, w, surfel, maxDistance) || hit;
    return hit;
}


void main() {

    // Generate an eye ray in camera space, and then transform to world space

    // Primary ray origin    
    Point3 P  = cameraToWorldMatrix[3];

    // Primary ray direction
    Vector3 w = Matrix3(cameraToWorldMatrix) * 
        normalize(Vector3((gl_FragCoord.xy - g3d_FragCoordExtent / 2.0) * Vector2(1, -1),
                          g3d_FragCoordExtent.y / ( -2.0 * tanHalfFieldOfViewY)));

    float maxDist = inf;       

    //////////////////////////////////////

    // Render the scene here
   
    Surfel surfel;
    if (traceRay(P, w, surfel, maxDist)){
       
       // pixelColor = surfel.material.lambertian;
        Vector3 wi = normalize(Vector3(1,1,1));
        Vector3 n = surfel.normal;
        Radiance3 biradiance = Radiance3(2.8, 2.3,1);
        Radiance3 ambientRadiance = Radiance3(.5, .3, .3)*surfel.material.lambertian;
        Surfel ignore;
        float shadowDist = inf;
        bool shadow = traceRay(surfel.position + n*.1, wi, ignore, shadowDist);
        Vector3 wo = -w;
        Vector3 wh = normalize(wi+wo);
        Color3 f = (surfel.material.lambertian/pi)+ (pow(max(dot(n,wh),0), max(surfel.material.sigma,1))*(surfel.material.sigma+8)*surfel.material.glossy)/(8*pi);
        pixelColor = f*biradiance*max(0,dot(n, wi))*float(!shadow)+ambientRadiance;
    } else{
        pixelColor = sampleTexture(environmentMap, w).rgb;
    }

    //////////////////////////////////////
     
    // Camera space z value
    float csZ = maxDist / w.z;
    
    // Pack into standard OpenGL depth buffer format to make the result compatible
    // with rasterization and post-processing.
    gl_FragDepth = (maxDist == inf) ? 1.0 : ((projectionMatrix22 * csZ + projectionMatrix23) / -csZ);
}
